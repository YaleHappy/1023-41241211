<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>打磚塊遊戲</title>
    <!-- Bootstrap 5.3.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        canvas {
            background: #eee;
            display: block;
            margin: 20px auto;
        }
        #startBtn {
            display: block;
            margin: 20px auto;
        }
        #difficultySelect {
            margin: 20px auto;
            display: block;
        }
        .centered {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>

</head>
<body>

    <select id="backgroundSelect" class="form-select w-50 mx-auto">
        <option value="night">夜空</option>
        <option value="forest">森林</option>
    </select>
    
    <div class="container text-center">
        <!-- 遊戲標題 -->
        <h1 class="mt-5">打磚塊遊戲</h1>

        <!-- 難度選擇下拉式選單 -->
        <select id="difficultySelect" class="form-select w-50 mx-auto">
            <option value="easy">簡單</option>
            <option value="medium">中等</option>
            <option value="hard">困難</option>
        </select>

        <audio id="backgroundMusic" src="music/背景音樂.mp3" loop></audio>
        <audio id="hitSound" src="music/擊打音效.mp3"></audio>
        
        <!-- 開始遊戲按鈕 -->
        <button id="startBtn" class="btn btn-primary btn-lg">開始遊戲</button>

        <!-- 遊戲畫布 -->
        <canvas id="gameCanvas" width="480" height="320"></canvas>
    </div>

    <!-- Bootstrap 5.3.3 JavaScript Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- 自定義遊戲程式碼 -->
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        let ballRadius = 10;
        let x = canvas.width / 2;
        let y = canvas.height - 30;
        let dx = 2;
        let dy = -2;

        let paddleHeight = 10;
        let paddleWidth = 75;
        let paddleX = (canvas.width - paddleWidth) / 2;

        let rightPressed = false;
        let leftPressed = false;

        let brickRowCount = 3;
        let brickColumnCount = 5;
        let brickWidth = 75;
        let brickHeight = 20;
        let brickPadding = 10;
        let brickOffsetTop = 30;
        let brickOffsetLeft = 30;
        let isLevelComplete = false;


        let bricks = [];
        let score = 0;
        let isGameOver = false;  // 遊戲結束狀態
        let currentLevel = 1;
        let lives = 3;  // 初始生命數
        let trail = [];  // 存儲球的歷史位置
        let maxTrailLength = 20;  // 尾跡的最大長度



        // 根據難度調整遊戲參數
        let difficulty = "easy";  // 預設難度為簡單
        const difficultySelect = document.getElementById("difficultySelect");
        

        difficultySelect.addEventListener("change", function () {
            difficulty = this.value;
        });

        // 點擊按鈕開始遊戲
        const startBtn = document.getElementById("startBtn");
        startBtn.addEventListener("click", function() {
    // 隱藏按鈕和難度選擇
    startBtn.style.display = "none";
    difficultySelect.style.display = "none";
    startBtn.classList.remove('centered');  // 移除居中樣式

    // 重置遊戲參數並開始遊戲
    startGame();
});

const backgroundSelect = document.getElementById("backgroundSelect");
const backgroundImages = {
    night: "background/夜空.png",
    forest: "background/森林.png"
};

let currentBackground = new Image();
currentBackground.src = backgroundImages.night;  // 預設為夜空

// 當玩家選擇新的背景時，更換背景圖片
backgroundSelect.addEventListener("change", function() {
    const selectedBackground = this.value;
    if (selectedBackground in backgroundImages) {
        currentBackground.src = backgroundImages[selectedBackground];
    } else {
        // 如果沒有選擇，預設使用夜空
        currentBackground.src = backgroundImages.night;
    }
});



function startGame() {
    // 播放背景音樂
    const backgroundMusic = document.getElementById("backgroundMusic");
    backgroundMusic.play();

    // 初始化遊戲狀態
    isGameOver = false;
    isLevelComplete = false;  // 確保遊戲開始時不顯示過關動畫

    // 根據難度設定參數
    if (difficulty === "easy") {
        dx = 2;
        dy = -2;
        brickRowCount = 3;
        brickColumnCount = 5;
        brickWidth = 75;
        brickHeight = 20;
    } else if (difficulty === "medium") {
        dx = 3;
        dy = -3;
        brickRowCount = 4;
        brickColumnCount = 6;
        brickWidth = 70;
        brickHeight = 20;
    } else if (difficulty === "hard") {
        dx = 4;
        dy = -4;
        brickRowCount = 5;
        brickColumnCount = 7;
        brickWidth = 65;
        brickHeight = 20;
    }

    // 重置球的位置和速度
    x = canvas.width / 2;
    y = canvas.height - 30;

    // 重置遊戲結束狀態
    isGameOver = false;

    // 初始化磚塊
    generateBricks();
    draw(); // 開始繪製遊戲畫面
}




        // 動態生成磚塊
        function generateBricks() {
    bricks = []; // 清空磚塊陣列
    // 動態計算每個磚塊的寬度以適應畫布寬度
    brickWidth = (canvas.width - (brickColumnCount - 1) * brickPadding - 2 * brickOffsetLeft) / brickColumnCount;
    
    for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
            let hitPoints = 1;  // 預設需要1次擊打
            if (difficulty === "medium" && Math.random() < 0.5) {
                hitPoints = 2;  // 中等難度有部分需要2次擊打
            } else if (difficulty === "hard") {
                hitPoints = Math.floor(Math.random() * 3) + 1;  // 困難難度隨機需要1-3次擊打
            }
            bricks[c][r] = { x: 0, y: 0, status: 1, hitPoints: hitPoints };
        }
    }
}


function drawBall() {
    // 存儲當前球的位置到歷史位置陣列
    trail.push({ x: x, y: y });
    if (trail.length > maxTrailLength) {
        trail.shift();  // 移除最舊的尾跡點
    }

    // 繪製尾跡（歷史位置）
    for (let i = 0; i < trail.length; i++) {
        let alpha = i / trail.length;  // 透明度從低到高
        ctx.beginPath();
        ctx.arc(trail[i].x, trail[i].y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0, 149, 221," + alpha + ")";  // 隨著位置的遠近改變透明度
        ctx.fill();
        ctx.closePath();
    }

    // 繪製當前球的位置
    ctx.beginPath();
    ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#0095DD";
    ctx.fill();
    ctx.closePath();
}


        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
        }

        // 繪製磚塊，根據擊打次數改變顏色
        function drawBricks() {
            for (let c = 0; c < bricks.length; c++) {
                for (let r = 0; r < bricks[c].length; r++) {
                    if (bricks[c][r].status == 1) {
                        let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;

                        // 根據 hitPoints 改變磚塊顏色
                        let hitPoints = bricks[c][r].hitPoints;
                        let color;
                        if (hitPoints === 3) {
                            color = "#FF0000";  // 紅色表示需要3次擊打
                        } else if (hitPoints === 2) {
                            color = "#FFA500";  // 橙色表示需要2次擊打
                        } else {
                            color = "#FFFF00";  // 黃色表示需要1次擊打
                        }

                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.closePath();

                        // 顯示剩餘的擊打次數
                        ctx.font = "16px Arial";
                        ctx.fillStyle = "#000000";
                        ctx.fillText(hitPoints, brickX + brickWidth / 2 - 5, brickY + brickHeight / 2 + 5);
                    }
                }
            }
        }

        function drawScore() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#0095DD";
    ctx.fillText("Score: " + score, 8, 20);
}


function drawGameOver() {
    const backgroundMusic = document.getElementById("backgroundMusic");
    backgroundMusic.pause();  // 停止背景音樂
    backgroundMusic.currentTime = 0;  // 將音樂重置到開頭

    ctx.font = "24px Arial";
    ctx.fillStyle = "#0095DD";
    ctx.fillText("Game Over", canvas.width / 2 - 50, canvas.height / 2);
    ctx.fillText("Score: " + score, canvas.width / 2 - 50, canvas.height / 2 + 30);

    restartGame();  // 顯示難度選擇和重新開始按鈕
}





// 修改 draw 函數，繪製背景圖片
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除畫布

    // 繪製背景圖片
    ctx.drawImage(currentBackground, 0, 0, canvas.width, canvas.height);

    if (isGameOver) {
        drawGameOver();  // 顯示遊戲結束結果
        return;  // 停止更新畫面
    }

    if (isLevelComplete) {
        drawLevelComplete();  // 顯示過關動畫
        return;
    }

    drawBricks();
    drawBall();
    drawPaddle();
    drawScore();
    drawLives();
    collisionDetection();

    // 檢測所有磚塊是否被清空
    if (checkAllBricksCleared()) {
        handleLevelComplete();  // 顯示過關動畫並跳轉到下一難度
        return;
    }

    // 邊界檢測和球的反彈邏輯
    if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
        dx = -dx;  // 左右邊界反彈
    }

    if (y + dy < ballRadius) {
        dy = -dy;  // 頂部邊界反彈
    } else if (y + dy > canvas.height - ballRadius) {
        if (x > paddleX && x < paddleX + paddleWidth) {
            dy = -dy;
        } else {
            lives--;  // 失去一條生命
            if (lives === 0) {
                isGameOver = true;  // 生命用完，遊戲結束
            } else {
                dy = -dy;  // 讓球從底部反彈回來
            }
        }
    }

    // 更新球的位置
    x += dx;
    y += dy;

    // 擋板移動控制
    if (rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 7;
    } else if (leftPressed && paddleX > 0) {
        paddleX -= 7;
    }

    requestAnimationFrame(draw);  // 持續更新畫面
}





function collisionDetection() {
    const hitSound = document.getElementById("hitSound");

    let allBricksCleared = true;  // 標記所有磚塊是否被清除

    for (let c = 0; c < bricks.length; c++) {
        for (let r = 0; r < bricks[c].length; r++) {
            let b = bricks[c][r];
            if (b.status == 1) {
                allBricksCleared = false;  // 尚有磚塊未被清除
                if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
                    dy = -dy;  // 反彈
                    hitSound.play();  // 播放擊打音效

                    if (b.hitPoints > 1) {
                        b.hitPoints--;  // 減少擊打次數
                    } else {
                        b.status = 0;  // 磚塊消失
                        score++;  // 增加分數
                    }
                }
            }
        }
    }

    // 如果所有磚塊被清除，設置過關狀態
    if (allBricksCleared) {
        isLevelComplete = true;
    }
}




        // 鍵盤控制事件監聽
        document.addEventListener("keydown", keyDownHandler, false);
        document.addEventListener("keyup", keyUpHandler, false);

        function keyDownHandler(e) {
            if (e.key == "Right" || e.key == "ArrowRight") {
                rightPressed = true;
            } else if (e.key == "Left" || e.key == "ArrowLeft") {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key == "Right" || e.key == "ArrowRight") {
                rightPressed = false;
            } else if (e.key == "Left" || e.key == "ArrowLeft") {
                leftPressed = false;
            }
        }

        // 滑鼠控制擋板移動
        document.addEventListener("mousemove", mouseMoveHandler, false);

        function mouseMoveHandler(e) {
            let relativeX = e.clientX - canvas.offsetLeft;
            if (relativeX > 0 && relativeX < canvas.width) {
                paddleX = relativeX - paddleWidth / 2;
            }
        }

        // 點擊畫布重新開始遊戲
        canvas.addEventListener("click", function() {
            if (isGameOver) {
                restartGame();
            }
        });

        function restartGame() {
    // 重置分數和遊戲狀態
    score = 0;
    lives = 3;  // 重置生命數
    isGameOver = false;

    // 顯示難度選擇下拉式選單和開始遊戲按鈕
    difficultySelect.style.display = "block";
    startBtn.style.display = "block";
    startBtn.classList.add('centered');  // 按鈕移動到畫布中央
}


function drawLives() {
    ctx.font = "16px Arial";
    ctx.fillStyle = "#0095DD";
    ctx.fillText("Lives: " + lives, canvas.width - 65, 20);
}

function checkAllBricksCleared() {
    for (let c = 0; c < bricks.length; c++) {
        for (let r = 0; r < bricks[c].length; r++) {
            if (bricks[c][r].status === 1) {
                return false;  // 還有磚塊存在
            }
        }
    }
    return true;  // 所有磚塊已被擊破
}


function drawLevelComplete() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);  // 清除畫布
    ctx.font = "24px Arial";
    ctx.fillStyle = "#00FF00";
    ctx.fillText("恭喜過關！", canvas.width / 2 - 60, canvas.height / 2);
}

function handleLevelComplete() {
    isLevelComplete = true;  // 設置過關狀態
    drawLevelComplete();  // 顯示過關動畫

    setTimeout(() => {
        // 2秒後自動進入下一關
        moveToNextLevel();
    }, 2000);  // 延遲2秒後開始下一關
}


function moveToNextLevel() {
    // 根據當前難度提升至下一難度
    if (difficulty === "easy") {
        difficulty = "medium";
    } else if (difficulty === "medium") {
        difficulty = "hard";
    } else {
        // 如果已經是最困難，則保持困難模式
        difficulty = "hard";
    }

    // 重置遊戲狀態，並開始下一關
    resetGame();
    startGame();
}


function resetGame() {
    // 重置相關的狀態
    score = 0;
    lives = 3;
    isLevelComplete = false;  // 重置過關狀態
}

    </script>

</body>
</html>
